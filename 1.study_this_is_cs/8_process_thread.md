# 프로세스와 스레드

<!-- TOC -->
* [프로세스와 스레드](#프로세스와-스레드)
      * [포그라운드 프로세스: 사용자가 보는 공간에서 사용자와 상호작용하며 실행된다.](#포그라운드-프로세스-사용자가-보는-공간에서-사용자와-상호작용하며-실행된다)
      * [백그라운드 프로세스: 사용자사 보지 못하는 곳에서 실행된다.](#백그라운드-프로세스-사용자사-보지-못하는-곳에서-실행된다)
      * [코드 영역(텍스트영역): 실행 가능한 명령어가 저장되는 공간, CPU가 읽고 실행할 명령어가 담겨있어 쓰기가 금지된 읽기 전용 공간이다.](#코드-영역텍스트영역-실행-가능한-명령어가-저장되는-공간-cpu가-읽고-실행할-명령어가-담겨있어-쓰기가-금지된-읽기-전용-공간이다)
      * [데이터 영역: 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간, 데이터 영역에 저장되는 데이터는 **정적 변수**나 **전역 변수**가 대표적이다.](#데이터-영역-프로그램이-실행되는-동안-유지할-데이터가-저장되는-공간-데이터-영역에-저장되는-데이터는-정적-변수나-전역-변수가-대표적이다)
      * [힙 영역: 프로그램을 만드는 사용자가 직접 할당 가능한 저장 공간.](#힙-영역-프로그램을-만드는-사용자가-직접-할당-가능한-저장-공간)
      * [스택 영역:  일시적으로 사용할 값들이 저장되는 공간](#스택-영역-일시적으로-사용할-값들이-저장되는-공간)
    * [PCB(Process Control Block)와 문맥 교환](#pcbprocess-control-block와-문맥-교환)
    * [프로세스의 상태](#프로세스의-상태)
      * [생성 상태(new): 프로세스를 생성 중인 상태로, 메모리에 적재되어 PCB를 할당받은 상태.생성 상태를 거친 프로세스는 준비상태가 되어 PCU의 할당을 기다린다.](#생성-상태new-프로세스를-생성-중인-상태로-메모리에-적재되어-pcb를-할당받은-상태생성-상태를-거친-프로세스는-준비상태가-되어-pcu의-할당을-기다린다)
      * [준비 상태(ready): 아직 자신의 차례가 아니기 때문에 기다리고 있는 상태.해당 상태에서 CPU를 할당 받으면 실행 상태가 되고, 해당 전환을 디스패치라고 한다.](#준비-상태ready-아직-자신의-차례가-아니기-때문에-기다리고-있는-상태해당-상태에서-cpu를-할당-받으면-실행-상태가-되고-해당-전환을-디스패치라고-한다)
      * [실행 상태(running): CPU를 할당받아 실행중인 상태, 일정 시간만 CPU를 사용할 수 있다. 타이머 인터럽트가 방생하면 다시 준비 상태가 되고, 실행도중 입출력장치를 사용하게 되면 대기 상태가 된다.](#실행-상태running-cpu를-할당받아-실행중인-상태-일정-시간만-cpu를-사용할-수-있다-타이머-인터럽트가-방생하면-다시-준비-상태가-되고-실행도중-입출력장치를-사용하게-되면-대기-상태가-된다)
      * [대기 상태(blocked): 프로세스가 입출력 작업을 요청하거나 바로 확보할 수 없는 자원을 요청하는 곧장 실행이 불가능한 조건에 놓이면 대기 상태가 된다. 실행 가능한 상태가 되면 다시 준비 상태가 되어 CPU 할당을 기다린다.](#대기-상태blocked-프로세스가-입출력-작업을-요청하거나-바로-확보할-수-없는-자원을-요청하는-곧장-실행이-불가능한-조건에-놓이면-대기-상태가-된다-실행-가능한-상태가-되면-다시-준비-상태가-되어-cpu-할당을-기다린다)
      * [종료 상태(terminated): 종료 상태는 프로세스가 종료된 상태를 말한다. 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다.](#종료-상태terminated-종료-상태는-프로세스가-종료된-상태를-말한다-프로세스가-종료되면-운영체제는-pcb와-프로세스가-사용한-메모리를-정리한다)
  * [멀티프로세스와 멀티스레드](#멀티프로세스와-멀티스레드)
      * [멀티프로세스: 웹 브라우저의 탭을 보면 하나의 탭마다 하나의 프로세스로 동작한다. 이렇게 동시에 여러 프로세스가 실행되는 것을 **멀티프로세스** 라고 한다.](#멀티프로세스-웹-브라우저의-탭을-보면-하나의-탭마다-하나의-프로세스로-동작한다-이렇게-동시에-여러-프로세스가-실행되는-것을-멀티프로세스-라고-한다)
      * [멀티스레드: 한 프로세스를 구성하는 코드를 동시에 실행하는 여러 스레드를 사용하는 방법](#멀티스레드-한-프로세스를-구성하는-코드를-동시에-실행하는-여러-스레드를-사용하는-방법)
  * [프로세스 간 통신](#프로세스-간-통신)
    * [공유 메모리: 데이터를 주고받는 프로세스가 공통적으로 사용할 메모리 영역을 두는 방식](#공유-메모리-데이터를-주고받는-프로세스가-공통적으로-사용할-메모리-영역을-두는-방식)
    * [메시지 전달: 프로세스 간 주고받을 데이터를 커널을 거쳐 메시지의 형태로 주고 받는 형식](#메시지-전달-프로세스-간-주고받을-데이터를-커널을-거쳐-메시지의-형태로-주고-받는-형식)
      * [파이프: 단방향 프로세스 간의 통신 도구.](#파이프-단방향-프로세스-간의-통신-도구-)
      * [시그널: 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기적인 신호](#시그널-프로세스에게-특정-이벤트가-발생했음을-알리는-비동기적인-신호)
<!-- TOC -->

 - 메모리에는 컴퓨터가 실행되는 순간부터 다양한 프로세스들이 적재되어 실행된다.
#### 포그라운드 프로세스: 사용자가 보는 공간에서 사용자와 상호작용하며 실행된다.
#### 백그라운드 프로세스: 사용자사 보지 못하는 곳에서 실행된다.
- 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스인 **데몬**도 있다. 윈도우 운영체제에서는 이를 **서비스**라고 부른다.
- 프로세스의 유형을 막론하고 하나의 프로세스를 구성하는 메모리 내의 정보는 크게 다르지 않다.
    - 커널영역에는 프로세스 제어 블록(PCB)라는 정보가 저장
    - 사용자영역에는 실행 중인 프로세스가 **코드 영역, 데이터 영역, 힙 영역, 스택 영역**으로 나뉘어 저장된다.
- 코드 영역과 데이터 영역은 프로그램 실행 도중 크기가 변하지 않아 **정적 할당 영역**이라 부른다.
- 힙 영역과 스택 영역은 프로그램 실행 도중 크기가 변할 수 있어 **동적 할당 영역**이라 부른다. 
#### 코드 영역(텍스트영역): 실행 가능한 명령어가 저장되는 공간, CPU가 읽고 실행할 명령어가 담겨있어 쓰기가 금지된 읽기 전용 공간이다.
#### 데이터 영역: 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간, 데이터 영역에 저장되는 데이터는 **정적 변수**나 **전역 변수**가 대표적이다.
#### 힙 영역: 프로그램을 만드는 사용자가 직접 할당 가능한 저장 공간.
- 프로그램 실행 중 자유롭게 할당하여 사용 가능한 메모리 공간이지만, 언젠가는 해당 공간을 반환해야 한다. 
- 반환하지 않으면 할당한 공간이 계속 메모리 내에 남아 메모리를 낭비해 메모리 누수를 일으킨다.
- 이러한 문제를 해결하기 위해 자체적으로 사용되지 않는 힙 메모리를 해제하는 가비지 컬렉션 기능을 제공하기도 한다.
#### 스택 영역:  일시적으로 사용할 값들이 저장되는 공간
- 함수의 실행이 끝나면 사라지는 매개변수, 지역 변수, 함수 복귀 주소 등이 스택 영역에 저장되는 대표적인 데이터들.
- 스택 트레이스(특정 시점에 스택 영역에 저장된 함수 호출 정보) 형태의 함수 호출 정보가 저장될 수 있다.
- 스택 트레이스로 문제의 발생 지점을 추적할 수 있어, 디버깅에 유용하게 사용된다. 

### PCB(Process Control Block)와 문맥 교환
- PCB는 프로세스를 식별할 수 있는 커널 영역 내의 정보
- 프로세스와 관련된 다양한 정보를 내포하는 구조체의 일종, 새로운 프로세스가 메모리에 적재 됐을 때 커널 영역에 만들어지고, 프로세스의 실행이 끝나면 폐기된다. 
- PCB에 담기는 정보(운영체제마다 차이가 있다.)
1. 프로세스 ID(이하 PID): 프로세스 식별 번호
2. 프로세스가 실행 과정에서 사용한 레지스터 값
3. 프로세스 상태: 프로세스가 현재 어떤 상태인지를 나타낸다.
4. CPU 스케줄링(우선순위)정보: 프로세스가 언제, 어떤 순서로 CPU를 할당받을지 나타낸다.
5. 메모리 관련 정보: 프로세스의 메모리상 적재 위치를 알 수 있다.
6. 파일 및 입출력장치 관련 정보
- 이 때 여러 PCB들은 커널 내에 프로세스 테이블의 형태로 관리되는 경우가 많다.
- 새롭게 실행되는 프로세스가 있으면 해당 프로세스의 PCB를 프로세스 테이블에 추가하고, 필요한 자원을 할당한다.
- `프로세스가 비정상 종료되어 사용한 자원이 회수 됐어도, 종료된 프로세스의 PCB가 남아있는 경우가 있다. 이러한 비정상 종료 상태는 좀비 프로세스라고 한다.`
- 프로세스가 실행된다는 말은 운영체제에 의해 CPU 자원을 할당받았다는 말과 같다.CPU가 프로세스를 구성하는 명령어와 데이터를 인출해 실행하고, 운영체제가 CPU 자원을 할당하기 때문이다.
- 다양한 프로세스들이 한정된 시간 동안 운영체제로부터 CPU의 자원을 번갈아 가며 할당받아서 이용한다는 말과 같은데, 타이머 인터럽트에 의해 제한된다.(타임아웃 인터럽트 라고도 부른다.)
- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다린다.
- 프로세스가 실행되다 타이머 인터럽트로 인해 CPU사용을 양보할 때의 예시 (1프로세스, 2프로세스) 
!['문맥 교환'](https://csnote.net/assets/img/os/context_switch.png)
1. 2 프로세스에게 양보를 하기 전 프로세스 1는 프로그램 카운터를 비롯한 레지스터 값과 메모리 정보, 실행을 위해 열었던 파일, 사용한 입출력장치 등의 중간 정보를 **백업**해야 한다.
2. 백업 대상이 되는 중간 정보, 프로세스의 수행을 재개하기 위해 기억해야 할 정보는 **문맥**이라고 하고, 프로세스 문맥은 해당 프로세스의 PCB에 명시된다.
3. 프로세스가 CPU 사용할 수 있는 시간이 다 되거나 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB에 문맥을 백업한다. 
4. 뒤이어 실행할 프로레스의 문맥을 복구한다. 
- PCB에 백업하고, 문맥을 복구해 새로운 프로세스를 실행하는 것을 문맥 교환이라고 한다. 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리
- 해당 문맥 교환이 너무 잦으면 캐시 미스가 발생할 가능성이 높아진다. (실행할 프로세스의 내용을 가져오는 작업이 빈번해지고, 큰 오버헤드로 이어질 수 있다.)

### 프로세스의 상태
- 하나의 프로세스는 여러 상태를 거치며 실행이 된다.
- 운엥체제는 PCB를 통해 프로세스의 상태를 인식하고 관리한다.프로세스의 상태 (생성, 준비, 실행, 대기, 종료 등이 있다.)
  !['프로세스 상태'](https://csnote.net/assets/img/os/process_state.png)
#### 생성 상태(new): 프로세스를 생성 중인 상태로, 메모리에 적재되어 PCB를 할당받은 상태.생성 상태를 거친 프로세스는 준비상태가 되어 PCU의 할당을 기다린다.
#### 준비 상태(ready): 아직 자신의 차례가 아니기 때문에 기다리고 있는 상태.해당 상태에서 CPU를 할당 받으면 실행 상태가 되고, 해당 전환을 디스패치라고 한다.
#### 실행 상태(running): CPU를 할당받아 실행중인 상태, 일정 시간만 CPU를 사용할 수 있다. 타이머 인터럽트가 방생하면 다시 준비 상태가 되고, 실행도중 입출력장치를 사용하게 되면 대기 상태가 된다.
#### 대기 상태(blocked): 프로세스가 입출력 작업을 요청하거나 바로 확보할 수 없는 자원을 요청하는 곧장 실행이 불가능한 조건에 놓이면 대기 상태가 된다. 실행 가능한 상태가 되면 다시 준비 상태가 되어 CPU 할당을 기다린다.
#### 종료 상태(terminated): 종료 상태는 프로세스가 종료된 상태를 말한다. 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다.

> #### 블로킹 입출력과 논블로킹 입출력
> - 블로킹 입출력: 프로세스가 입출력 작업이 완료될 때까지 대기 상태로 머무는 방식
> - 논블로킹 입출력: 프로세스가 입출력 작업을 요청한 후 완료 여부와 상관없이 즉시 실행을 계속하는 방식
> 
> <img alt="&#39;블로킹 입출력&#39;" height="300px" src="https://csnote.net/assets/img/os/blocking_io.png"/>
> <img alt="&#39;논블로킹 입출력&#39;" height="300px" src="https://csnote.net/assets/img/os/nonblocking_io.png"/>

## 멀티프로세스와 멀티스레드
#### 멀티프로세스: 웹 브라우저의 탭을 보면 하나의 탭마다 하나의 프로세스로 동작한다. 이렇게 동시에 여러 프로세스가 실행되는 것을 **멀티프로세스** 라고 한다.
    - 중요한 점은 각기 다른 프로세스들이 기본적으로 자원을 공유하지 않고, 독립적으로 실행되는 점이다.
    - 각각 PID 가 다르고, 프로세스 별로 파일과 입출력장치 등의 자원이 독립적으로 할당되어 서로 영향을 거의 끼치지 않는다. 
#### 멀티스레드: 한 프로세스를 구성하는 코드를 동시에 실행하는 여러 스레드를 사용하는 방법
    - 스레드는 스레드를 식별할 수 있는 고유 정보인 스레드 ID와 프로그램 카운터, 레지스터 값, 스택 등으로 구성된다.
    - 스레드마다 다음에 실행할 주소를 가질 수 있고, 연산 과정의 임시 저장 값을 가질 수 있다. 
- 둘의 큰 차이점에는 자원의 공유 여부에 있다.
- 프로세스들은 기본적으로 같은 자원을 공유하지 않아 독립적, 같은 프로세스를 실행하는 여러 스레드들은 프로세스의 자원을 공유한다. 
- 스레드들은 동일한 주소 공간의 코드, 데이터, 힙 영역을 공유하고, 열린 파일과 같은 프로세스의 자원을 공유한다. 다만, 한 스레드에 생긴 문제가 전페의 문제가 될 수 있다.

## 프로세스 간 통신
- 기본적으로 프로세스간에는 자원을 공유하지 않지만, 프로세스 간에도 자원을 공유하고 데이터를 주고 받을 수 있는 방법이 있다. 이를 프로세스 간 통신(IPC)라 한다.
- 프로세스간 통신 방법은 크게 두가지 이다. 공유 메모리와 메시지 전달이 두가지 이다.
### 공유 메모리: 데이터를 주고받는 프로세스가 공통적으로 사용할 메모리 영역을 두는 방식
- 프로세스는 기본적으로 자원을 공유하지 않으므로 특정 프로세스가 다른 프로세스의 메모리 공간을 임의로 수정할 수 없다.
- 공유 메모리라는 특별한 메모리 공간을 할당하면 프로세스가 해당 메모리 공간을 공유하여 읽고 쓸 수 있게 된다.
- 공유 메모리 기반 IPC는 프로세스가 송유하는 메모리 영역을 확보하는 시스템 콜을 기반으로 수행될 수 있고, 간단하게 프로세스가 공유하는 변수나 파일을 활용할 수도 있다.
- 공유 메모리 기반 IPC의 가장 중요한 특징은 주고받은 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신한다는 것이다. 그리고 데이터를 주고받는 과정에서 커널의 개입이 거의 없다.
- 각 프로세스가 각자의 메모리 영역을 읽고 쓰는 것 뿐이므로 통신 속도가 빠르다.
- 대신 각각의 프로세스가 서로의 공유 메모리 영역을 동시에 읽고 쓸 경우, 데이터의 일관성이 훼손될 수 있다. 이를 레이스 컨디션이라 한다. 
### 메시지 전달: 프로세스 간 주고받을 데이터를 커널을 거쳐 메시지의 형태로 주고 받는 형식
- 메시지 전달 기반 IPC는 메시지를 보내는 수단과 받는 수간이 명확하게 구분되어 있다. 메시지를 보내는 send() 시스템 콜 ,받는 recv() 시스템 콜이 정해져 있다. 
- 프로세스는 두 시스템 콜을 호출하며 메시지를 송수신할 수 있다. 
- 메시지 전달 기반 IPC는 공유 메모리 기반 IPC보다 커널의 도움을 적극적으로 받을 수 있어 레이스 컨디션, 동기화 등의 문제를 고려하는 일이 상대적으로 적다.
- 다만 데이터가 커널을 통해 송수신 되므로 공유 메모리 기반 IPC보다 통신 속도는 느리다.
- 메시지 전달 기반 IPC를 위한 대표적인 수단은 파이프, 시그널, 소켓, 원격 프로시저 호출(RPC)등이 있다.
#### 파이프: 단방향 프로세스 간의 통신 도구. 
    - 부모 프로세스와 자식 프로세스 간에 통신만 가능.
    - 단방향으로만 읽고 쓸 수 있는 파이프로 양방향 통신을 수행할 경우, 읽기용 파이프와 쓰기용 파이프 2개를 이용해 양방향으로 통신하는 경우가 많다.
#### 시그널: 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기적인 신호
    - 시그널의 종류는 다양하다. 즉, 시그널을 발생시키는 이벤트의 종류는 다양하다. 
    - 프로세스는 시그널이 발생하면 여느 인터럽트 처리 과정과 유사하게 하던 일을 잠시 중단하고, 시그널 처리를 위한 시그널 핸들러를 실행한 뒤 실행을 재개한다.
    - 이때 프로세스는 직접 특정 시그널을 발생시킬 수 있고, 직접 일부 시그널 핸들러를 정의할 수 있따. 
    - 시그널이 발생했을 때의 동작을 정의하여 프로세스에게 해당 시그널을 봄으로꺼 프로세스간 통신을 수행할 수 있다.
    - 비동기적으로 원하는 동작을 수행할 수 있는 좋은 수단이다. 

- 이 외에도 원격 프로시저 호출(RPC)나 네트워크 소켓을 통해 IPC를 수행할 수도 있다. 다른 프로세스의 원격 코드실행
- RPC를 통해 성능 저하를 최소화하고, 메시지 송수신이 가능하기에 대규모 트래픽 처리 환경, 서버간 통신 환경에서 사용되는 경우가 많다.

> <img alt="&#39;공유 메모리&#39;" height="300px" src="https://csnote.net/assets/img/os/shared_memory.png"/>
> <img alt="&#39;메시지 전달&#39;" height="300px" src="https://csnote.net/assets/img/os/message_passing.png"/>
