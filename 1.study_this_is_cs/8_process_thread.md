# 프로세스와 스레드
 - 메모리에는 컴퓨터가 실행되는 순간부터 다양한 프로세스들이 적재되어 실행된다.
#### 포그라운드 프로세스: 사용자가 보는 공간에서 사용자와 상호작용하며 실행된다.
#### 백그라운드 프로세스: 사용자사 보지 못하는 곳에서 실행된다.
- 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스인 **데몬**도 있다. 윈도우 운영체제에서는 이를 **서비스**라고 부른다.
- 프로세스의 유형을 막론하고 하나의 프로세스를 구성하는 메모리 내의 정보는 크게 다르지 않다.
    - 커널영역에는 프로세스 제어 블록(PCB)라는 정보가 저장
    - 사용자영역에는 실행 중인 프로세스가 **코드 영역, 데이터 영역, 힙 영역, 스택 영역**으로 나뉘어 저장된다.
- 코드 영역과 데이터 영역은 프로그램 실행 도중 크기가 변하지 않아 **정적 할당 영역**이라 부른다.
- 힙 영역과 스택 영역은 프로그램 실행 도중 크기가 변할 수 있어 **동적 할당 영역**이라 부른다. 
#### 코드 영역(텍스트영역): 실행 가능한 명령어가 저장되는 공간, CPU가 읽고 실행할 명령어가 담겨있어 쓰기가 금지된 읽기 전용 공간이다.
#### 데이터 영역: 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간, 데이터 영역에 저장되는 데이터는 **정적 변수**나 **전역 변수**가 대표적이다.
#### 힙 영역: 프로그램을 만드는 사용자가 직접 할당 가능한 저장 공간.
- 프로그램 실행 중 자유롭게 할당하여 사용 가능한 메모리 공간이지만, 언젠가는 해당 공간을 반환해야 한다. 
- 반환하지 않으면 할당한 공간이 계속 메모리 내에 남아 메모리를 낭비해 메모리 누수를 일으킨다.
- 이러한 문제를 해결하기 위해 자체적으로 사용되지 않는 힙 메모리를 해제하는 가비지 컬렉션 기능을 제공하기도 한다.
#### 스택 영역:  일시적으로 사용할 값들이 저장되는 공간
- 함수의 실행이 끝나면 사라지는 매개변수, 지역 변수, 함수 복귀 주소 등이 스택 영역에 저장되는 대표적인 데이터들.
- 스택 트레이스(특정 시점에 스택 영역에 저장된 함수 호출 정보) 형태의 함수 호출 정보가 저장될 수 있다.
- 스택 트레이스로 문제의 발생 지점을 추적할 수 있어, 디버깅에 유용하게 사용된다. 

### PCB(Process Control Block)와 문맥 교환
- PCB는 프로세스를 식별할 수 있는 커널 영역 내의 정보
- 프로세스와 관련된 다양한 정보를 내포하는 구조체의 일종, 새로운 프로세스가 메모리에 적재 됐을 때 커널 영역에 만들어지고, 프로세스의 실행이 끝나면 폐기된다. 
- PCB에 담기는 정보(운영체제마다 차이가 있다.)
1. 프로세스 ID(이하 PID): 프로세스 식별 번호
2. 프로세스가 실행 과정에서 사용한 레지스터 값
3. 프로세스 상태: 프로세스가 현재 어떤 상태인지를 나타낸다.
4. CPU 스케줄링(우선순위)정보: 프로세스가 언제, 어떤 순서로 CPU를 할당받을지 나타낸다.
5. 메모리 관련 정보: 프로세스의 메모리상 적재 위치를 알 수 있다.
6. 파일 및 입출력장치 관련 정보
- 이 때 여러 PCB들은 커널 내에 프로세스 테이블의 형태로 관리되는 경우가 많다.
- 새롭게 실행되는 프로세스가 있으면 해당 프로세스의 PCB를 프로세스 테이블에 추가하고, 필요한 자원을 할당한다.
- `프로세스가 비정상 종료되어 사용한 자원이 회수 됐어도, 종료된 프로세스의 PCB가 남아있는 경우가 있다. 이러한 비정상 종료 상태는 좀비 프로세스라고 한다.`
- 프로세스가 실행된다는 말은 운영체제에 의해 CPU 자원을 할당받았다는 말과 같다.CPU가 프로세스를 구성하는 명령어와 데이터를 인출해 실행하고, 운영체제가 CPU 자원을 할당하기 때문이다.
- 다양한 프로세스들이 한정된 시간 동안 운영체제로부터 CPU의 자원을 번갈아 가며 할당받아서 이용한다는 말과 같은데, 타이머 인터럽트에 의해 제한된다.(타임아웃 인터럽트 라고도 부른다.)
- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다린다.
- 프로세스가 실행되다 타이머 인터럽트로 인해 CPU사용을 양보할 때의 예시 (1프로세스, 2프로세스) 
!['문맥 교환'](https://csnote.net/assets/img/os/context_switch.png)
1. 2 프로세스에게 양보를 하기 전 프로세스 1는 프로그램 카운터를 비롯한 레지스터 값과 메모리 정보, 실행을 위해 열었던 파일, 사용한 입출력장치 등의 중간 정보를 **백업**해야 한다.
2. 백업 대상이 되는 중간 정보, 프로세스의 수행을 재개하기 위해 기억해야 할 정보는 **문맥**이라고 하고, 프로세스 문맥은 해당 프로세스의 PCB에 명시된다.
3. 프로세스가 CPU 사용할 수 있는 시간이 다 되거나 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB에 문맥을 백업한다. 
4. 뒤이어 실행할 프로레스의 문맥을 복구한다. 
- PCB에 백업하고, 문맥을 복구해 새로운 프로세스를 실행하는 것을 문맥 교환이라고 한다. 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리
- 해당 문맥 교환이 너무 잦으면 캐시 미스가 발생할 가능성이 높아진다. (실행할 프로세스의 내용을 가져오는 작업이 빈번해지고, 큰 오버헤드로 이어질 수 있다.)

### 프로세스의 상태
- 하나의 프로세스는 여러 상태를 거치며 실행이 된다.
- 운엥체제는 PCB를 통해 프로세스의 상태를 인식하고 관리한다.프로세스의 상태 (생성, 준비, 실행, 대기, 종료 등이 있다.)
  !['프로세스 상태'](https://csnote.net/assets/img/os/process_state.png)
#### 생성 상태(new): 프로세스를 생성 중인 상태로, 메모리에 적재되어 PCB를 할당받은 상태.생성 상태를 거친 프로세스는 준비상태가 되어 PCU의 할당을 기다린다.
#### 준비 상태(ready): 아직 자신의 차례가 아니기 때문에 기다리고 있는 상태.해당 상태에서 CPU를 할당 받으면 실행 상태가 되고, 해당 전환을 디스패치라고 한다.
#### 실행 상태(running): CPU를 할당받아 실행중인 상태, 일정 시간만 CPU를 사용할 수 있다. 타이머 인터럽트가 방생하면 다시 준비 상태가 되고, 실행도중 입출력장치를 사용하게 되면 대기 상태가 된다.
#### 대기 상태(blocked): 프로세스가 입출력 작업을 요청하거나 바로 확보할 수 없는 자원을 요청하는 곧장 실행이 불가능한 조건에 놓이면 대기 상태가 된다. 실행 가능한 상태가 되면 다시 준비 상태가 되어 CPU 할당을 기다린다.
#### 종료 상태(terminated): 종료 상태는 프로세스가 종료된 상태를 말한다. 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다.

## 멀티프로세스와 멀티스레드

## 프로세스 간 통신
### 공유 메모리
### 메시지 전달
