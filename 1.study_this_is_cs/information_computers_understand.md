# 컴퓨터가 이해하는 정보

CPU는 기본적으로 0솨 1만을 이해할 수 있다. 이 가장 작은 단위를 `비트` 라고 한다.
n비트는 2의 n 제곱개의 정보를 표현 할 수 있다. ex) 2bit =  4개

- 비트(메가바이트, 기가...): 프로그램의 크기를 나타내는 정보 단위

  | 구분    | 비트        |                 |
  |-------|-----------|-------------------|
  | 1byte | 8비트       | 256개의 정보 표현 가능|
  | 1kB   | 1000바이트   |                |
  | 1MB   | 1000킬로이트  |                |
  | 1GB   | 1000메가바이트 |                |
  | 1TB   | 1000테라바이트 |                |
-  워드 : CPU가 한번에 처리할 수 있는 데이터의 크기 
- 예를 들어 2GB 짜리 프로그램을 실핼 할 떄 2GB응 한번에 읽는 것이 아니고 , 워드 단위로 읽어들인다. 
- CPU 마다 워드의 크기는 다르다. 보통 32비트 , 64비트 단위

### 1. 0과 1로 숫자 표현하기 

- CPU는 0, 1의 이진법을 사용, 숫자 1을 넘어가느 시점에 자리올림해 수를 표현
- 소수를 나타내는 방법을 알아보자 !
  - 표현하고자 하는 소수와 실제 저장된 소수간에 오차가 생길 수 있다. 0.1+0.2 === 0.3 하면 해당 식은 false가 나온다,
  - **부동소수점 방식** (floating point 방식)이 있다.
    - 소수점이 고정되지 않은 소수 표현 방식
    - 필요에 따라서 소수점의 위치가 이동할 수 있고 유동적이다. 
    - 10진수 123.123 -> m X 10ⁿ 꼴로보여주면
    - 1.23123* 10²  -> 1.23123 === 가수 2 === 지수 
    - 12312.3*10⁻² -> 12312.3 === 가수 -2 === 지수
    - 10진수 -> 2진수로 변경하면 1101011.1010101
    - 1.1010111010101 * 2⁶
    - 110101110.10101 * 2⁻²
    - **소수가 저장이 되는 방법** > 여기서 IEEE 754의 부동소수점 저장방식으로
      - 가수의 정수부: `1로 통일된 정규화한 수`가 저장이 된다.
      - 가수 -> 1.****형태  그래서 위의 수는 **1.1010111010101 * 2⁶** 로 저장이 된다. 
      - 또한 1은 통일이어서 , 1. 울 제외한 **** 부분(소수부분)만 저장을 하게 된다. 
    - **지수가 저장이 되는 방법** > 바이어스 값이 더해진다.
      - 지수표현에 들어간 비드 값 -1 즉  2ⁿ⁻¹-1 ex)8비트가 사용이 되었다면 2⁷-1 인 127
    - 해당 10진수 소수를 2진수로 표현할 때, 10진수 소수와 2진수 소수의 표현이 딱 맞아떨어지지 않을 수 있다. 
    - 컴퓨터 저장공간이 한정적이어서 일부 소수점을 생략하는 현상이 발생한다.
    
      ![부동소수점](https://csnote.net/assets/img/arch/floatingpoint.png)

### 2. 0과 1로 데이터 표현하기

- 문자집합 : 컴퓨터가 이해할 수 있는 문자들의 집합  가장 기본적인 문자집합 **아스키**
- 문자 인코딩 : 한 문자 -> 0, 1로 변환 
- 문자 디코딩 : 0, 1 -> 문자로 변환

#### 아스키
 - 초창기 컴퓨터에서 사용하던 문자집합 중 하나 , 영어 알파벳,아라비아 숫자, 일부 특수 문자 포함
 - 하나의 아스키 문자 표현을 위해서 8비트 사용 (1비트는 패리티비트 -오류 검출용 , 7비트는 실질적인 문자표현 2⁷ = 128 개 문자 표현가능 )
 - **아스키 코드표**를 보고 아스키 문자에 대응되는 고유한 수는 **아스키 코드**라 한다. 
### EUC-KR
한글을 표기하기 위해 등장한 한글 인코딩 방식 
한글 글자 하나는 2바이트 크기의 코드를 부여 2바이트는 네자리의 16진수로 표현 할 수 있다.

해당 방식으로는 총 2,350개 정도의 한들 단어를 표현 할 수 있다. 아직 표현할 한글조합은 안된다. 
### 유니코드 
- 표현되지 않는 언어로 인해 생긴 것이 유니코드이다. 
- 한글을 포함해 훨씬 많은 한글. 특수문자, 화살표, 이모티콘도 코드로 표현하는 통일된 문자 집합니다.
- 국가별의 문자집합과 인코딩 방식을 준비할 필요가 없다 .
- 현대 가장 많이 사용되는 표준 문자 집합에는 고유한 값이 부여된다. 
- 고유한 값에 다양한 방법으로 인코딩을 하는데 해당 방법등에는 UTF-8, UTF-16, UTF-32 등이 있다. 
- UTF-8, UTF-16, UTF-32는 가변 길이 인코딩 방식이다. 즉. 인코딩 된 결과의 길이가 일정하지 않을 수 있다는의미 
### base64
- 문자 뿐만 아니라 , 이진 데이터, 이미지 등  문자 의외의 데이터까지 표현 할 수 있다. 
- 64진법으로 6비트가 필요하다.
- 예를 들어 8비트로 인코딩된 문자열 abc 를 변환하면 각각 6비트씩 끊어 YWJI 가된다. 
- 근데 ab를 변환할 경우에는 6비트씩 끊으면 나누어 떨어지지 않아 비트 수가 부족하다. 부족한 비트는 0으로 간주 되고 = 으로 인코딩 된다. -> YWI=

### 명령어

![명령어구조](https://csnote.net/assets/img/arch/instructionstructure.png)
- 명령어 = 수행할 동작 **연산코드**+ 수행할 대상 (데이터 자체, 데이터가 저장이 된 위치) **오퍼랜드**
- 오퍼랜드에서 사용될 데이터가 직접 명시되는 것 보다는 연산 코드에 사용될 데이터가 저장된 위치(메모리 주소 , 레지스터 이름)이 명시된다. 
- 연산코드필드 (연산토드가 담기는 영역) , 오퍼랜드필드(오퍼랜드가 담기는 영역, 주소 필드로 부르기도 한다.)
- 명령어에 사용된 오퍼랜드 필드에 메모리 주소가 명시되어 있으면 실행을 위해 메모리 접근이 더 필요하다.

#### 연산코드 
CPU에 따라 연산코드의 구체적인 생김새가 다르다.
대표적인 연산 코드 유형은 데이터전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어가 있다.

| 유형       | 연산코드                           | 설명                              |
|----------|--------------------------------|---------------------------------|
| 데이터전송    | MOVE                           | 데이터 옮기기                         |
|          | STORE                          | 메모리에 저장하기                       |
|          | LOAD                           | 데이터를 메모리에서 CPU로 가져와라            |
|          | PUSH                           | 데이터를 스택에 저장해라                   |
|          | POP                            | 스택의 최상단 데이터를 가져와라               |
| 산술/논리 연산 | ADD/SUBSTRACT/MULTIIPLY/DIVIDE | 덧셈,뺄셈,곱셈,나눗셈을 수행하라              |
|          | INCREMENT,DECREMENT            | 오퍼랜드에  1을 더해라. 오퍼랜드에서 1을 빼라     |
|          | AND/OR/NOT                     | AND/OR/NOT 연산을 수행해라             |
|          | COMPARE                        | 두개의 숫자.혹은 TRUE/FALSE값을 비교해라     |
| 제어 흐름 변경 | JUMP                           | 특정 주소로 실행 순서를 옮겨라               |
|          | CONDITIONAL JUMP               | 조건에 부합할 경우 특정 주소로 실행 순서를 옮겨라    |
|          | HALT                           | 프로그램의 실행을 멈춰라                   |
|          | CALL                           | 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라 |
|          | RETURN                         | CALL을 호출할 때 저장했던 주소로 돌아라가       |
| 입출력 제어   | READ(INPUT)                    | 특정 입출력장치로부터 데이터를 읽어라            |
|          | WRITE(OUTPUT)                  | 특정 입출력장치로 데이터를 써라               |
|          | START IO                       | 입출력장치를 시작해라                     |
|          | TEST IO                        | 입출력장치의 현재 상태를 확인해라              |
